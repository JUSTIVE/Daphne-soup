# 백지에서

프로그래밍은 타입과 함수로 시작합니다. 아마도 여러분들은 타입이 무엇이고, 함수가 무엇이고 하는 사전 지식이 있을 것입니다. 이를 모두 버리세요. 이들은 우리의 머리를 흐리게 할 것입니다.


  하드웨어에 어떻게 구현되었는지에 대해 생각하지 마세요. 컴퓨터는 그저 여러 계산 모델 중의 하나일 뿐입니다. 우리는 이에 국한되어선 안됩니다. 우리는 머리속에서 계산을 할 수도 있고, 혹은 펜과 종이로도 할 수 있습니다. 물질적 존재는 프로그래밍의 개념과는 무관합니다.

## 1.1 타입과 함수

노자를 인용하면: 설명할 수 있는 타입은 무한한 타입이 아니다(도가도비상도:道可道非常道, 말할 수 있는 도는 도가 아니다), 다른 말로는, 타입은 원시적인 개념이다. 이는 정의될 수 없는 것이다.
  타입이라 부르는 것 대신, 우리는 이것을 객체나 명제로 부를 수 있습니다. 이러한 단어들은 다양한 수학의 분야들에서 쓰이는 용어입니다.(범주론, 유형론, 논리, 등).

---
타입 이론 type theory -> 타입 type  
범주론 category theory -> 대상 object  
논리학 logic -> 명제 proposition
---


세상엔 하나 이상의 타입이 존재할 수 있습니다. 따라서 우리는 이에 이름을 붙여야 합니다. 물론 이것들에 삿대질을 할 수도 있겠지만, 더 효율적인 소통을 위해 우리는 보통 이름을 붙입니다. 따라서, 우리는 a, b, c 혹은 Int, Bool, Double 등과 같이 타입을 부를 것입니다. 이들은 그저 이름일 뿐입니다.

타입 그 자체로는 아무런 의미를 가지지 않습니다. 다른 타입들과 연결되는 방법이 타입을 특별한 존재로 만듭니다. 이러한 연결은 화살표로 표현됩니다. 화살표는 하나의 입력과 하나의 타겟을 가집니다. 이 타겟은 입력가 같을 수 있습니다. 이 경우에는 화살표는 루프를 가집니다.

두 타입 사이의 화살표는 함수`function`라 불립니다. 두 객체 사이의 화살표는 사상`morphism`이라 불립니다. 두 명제 사이의 화살표는 논리적 귀결`entailment`라 불립니다. 이들은 여러 분야의 수학들에서 이 화살표를 나타내는 용어입니다. 이 이름들을 서로 바꾸어서 사용할 수 있습니다.

---
type theory -> 함수 function  
category theory -> 사상 morphism  
logic -> 수반 entailment, 함축 implication
---

명제는 참일 수 있는 어떤 것입니다. 논리학에서, 두 객체 사이의 화살표를 `a entails b` 혹은 `b는 a로부터 도출될 수 있다`고 표현합니다. 두 타입 간에 하나 이상의 화살표가 있을 수 있습니다. 따라서 이것들에 이름을 붙여야 합니다. 예를 들어, type a 에서 type b 로 가는 화살표를 f 라 부를 수 있습니다.

$$ a \xrightarrow{f} b $$
이것을 표현하는 방법으로는, type a의 인자를 받아 type b의 결과를 반환하는 함수를 f라 부르는 것입니다. 혹은, f는 a 가 참이라면 b 또한 참이라는 증명입니다.
노트: 타입 이론, 람다 대수, 논리학, 범주론의 상관관계는 커리-하워드-램백 대응(혹은 커리-하워드 대응)으로 알려져 있습니다.

> Curry-Howard-Lambek 대응
> (커리-하워드 대응: 수학적 증명과 프로그래밍의 연결)  
>   수학에서의 증명을 프로그래밍 언어에서의 type으로 볼 수 있으며,
>   증명의 구성은 해당 타입의 프로그램(함수)로 볼 수 있다.
>   -> 프로그램이 타입 검사를 통과한다면, 그 프로그램은 일종의 `수학적 증명`을 완성한 것으로 볼 수 있다.   
> (램벡 대응: 카테고리 이론의 연결)


## 1.2 음과 양

대상은 연결로 정의할 수 있습니다.
화살표는 증명이고, 두 대상이 연결되어있다는 사실의 목격자입니다.
때로는 대상이 연결되어있지 않을 수도, 때로는 너무 많은 증명이 있을 수 있고, 때로는 하나의 증명:두 대상간의 고유한 화살표가 있을 수도 있습니다.
 여기서의 _고유하다_ 는 의미는, 이와 동일한 것을 2개 발견했을 때, 이 둘이 같은 것입니다. 
한 대상에서 범주 내의 모든 대상으로 향하는 화살표를 가지는 대상은 _초기 대상_ 이라 합니다. 이와 쌍을 이루는, 모든 대상에서 오는 화살표를 받는 대상은 _끝 대상_ 이라 합니다. 
 수학에서 초기 대상은 일반적으로 0으로 표기되고, 끝 대상은 일반적으로 1으로 표기됩니다. 초기 대상은 모든 것의 원천입니다. Haskell에서는 Void 타입으로 표현합니다. Void는 모든 것으로 향하기 때문에, Void는 자기 자신으로 향하는 화살표가 있습니다. 따라서 Void는 void와 모든 것들을 야기합니다.
끝 대상은 모든 것을 합칩니다. Haskell에서는 Unit 타입으로 표현합니다. 참진리를 의미하며, T 혹은 $\top$와 같이 표기되고, Void는 $\bot$ 과 같이 표기됩니다.

| 프로그래밍 | 수학 | 논리학 | 
| --- | --- | --- |
| type | object | proposition |
| function | morphism | implication |
| Void| initial object,0 | False $\bot$ |
| () | terminal object,1 | True $\top$ |

## 1.3 원소들

대상의 내부에는 각 원소는 없으나 대상을 향하는 화살표로 구성된 구조들이 있습니다. 우리는 이 화살표를 통해 대상을 증명할 수 있습니다. 
프로그래밍과 논리학에서는 초기 대상은 아무 구조를 가지지 않습니다.
따라서 자기 자신으로부터 출발한 화살표를 제외하고는 들어오는 화살이 없는 것으로 간주할 수 있습니다.
따라서 `Void` 타입은 아무 구조를 가지지 않습니다.  
끝 대상은 가장 간단한 구조입니다. 모든 대상으로부터 출발하는 화살표가 있고, 끝 대상에서 출발해서 다른 대상으로 향하는 사상을 이용하면 다른 대상의 구조를 살펴볼 수 있습니다. 만약 끝 대상에서 대상 a로 향하는 하나 이상의 화살표가 있다면, 이 대상은 어떤 구조를 가지고 있다는 것을 의미합니다: 이 대상을 보는 하나 이상의 방법이 있다는 것입니다.((하나 이상의 원소를 가지고 있다는 뜻인듯?))

범주론에서 x가 a의 전역 원소라면 이는 다음과 같이 표기할 수 있습니다.



| 범주론 | 유형론 | Haskell | 
| --- | --- | --- |
| $ 1 \xrightarrow x  a $ | x:A | x :: A|  

하스켈에서는 x::A와 x::() -> A 를 구분하나, 카테고리적 의미에서는 동일한 의ㅁ을 가지고 있습니다.